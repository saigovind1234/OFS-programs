Ram and Bheem are working on the singly linked list concept.
They have chosen a number each, num1 and num2.

If the number is 432, then the linked list is created as 2->3->4.

Your task is to help Mr Ram and Bheem to find the addition of num1 and num2.
And display the result as shown in sample testcases.

Input Format:
-------------
Line-1: two space separated integers, N and M, length of num1 and num2.
Line-2: N space separated integers, digits of the num1, from end to start.
Line-3: M space separated integers, digits of the num2, from end to start.

Output Format:
--------------
Print the digits of the addition result.

NOTE:
-----
You may assume the num1, num2, do not contain any leading zero, 
except the value of num1/num2 is 0 itself.
i.e., the list do not conatin any trailing zero.


Sample Input-1:
---------------
3 3
1 2 3
4 5 6

Sample Output-1:
----------------
5 7 9

Explanation:
------------
Original numbers are num1=321 and num2=654
Addition is 321+654= 975 => the output is 5 7 9.


Sample Input-2:
---------------
4 3
4 3 5 6
8 7 6

Sample Output-2:
----------------
2 1 2 7

Explanation:
------------
Original numbers are num1=6534 and num2=678
Addition is 6534+678= 7212 => the output is 2 1 2 7.
test case:
case =1
input =4 3
4 3 5 6
8 7 6
output =2 1 2 7

case =2
input =6 3
9 9 9 9 9 9
9 9 9
output =8 9 9 0 0 0 1

case =3
input =6 5
8 5 3 9 7 9
7 8 4 6 9
output =5 4 8 5 7 0 1

case =4
input =10 7
9 4 6 7 4 5 6 3 4 7
8 4 3 2 8 9 4
output =7 9 9 9 2 5 1 4 4 7

case =5
input =16 12
9 4 6 7 4 5 6 3 4 7 8 5 3 9 7 9
8 4 3 2 8 9 4 7 8 4 6 9
output =7 9 9 9 2 5 1 1 3 2 5 5 4 9 7 9

case =6
input =6 7
7 0 0 0 8 7
0 0 0 8 7 8 6
output =7 0 0 8 5 6 7
ans:
import java.util.*;
class Node{
    int data;
    Node next;
    Node(int d){
        data=d;
        next=null;
    }
}
class ll{
    public   Node hptr=null;
    public  void append(int d){
        if(hptr==null){
            hptr=new Node(d);
        }
        else{
        Node temp=hptr;
        
        while(temp.next!=null){
            temp=temp.next;
        }
        Node f=new Node(d);
        temp.next=f;
        }
    }

    public static ll sum(Node g,Node c){
       ll h=new ll();
       int c1=0;
       while(g!=null || c!=null){
           int y=0;
           if(g!=null){
               y=y+g.data;
           }
           if(c!=null){
               y=y+c.data;
           }
          y=y+c1;
           h.append(y%10);
           c1=y/10;
           if(g!=null){           g=g.next;
           }
           if(c!=null){
           c=c.next;
           }
       }
       if(c1!=0){
           h.append(c1);
       }
       return h;
    }
    public static void display(Node b){
        Node v=b;
        while(v!=null){
            System.out.print(v.data+" ");
            v=v.next;
        }
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();
        int b=sc.nextInt();
 
        ll h=new ll();
        ll m=new ll();
        for(int i=0;i<a;i++){
            int g=sc.nextInt();
            h.append(g);
        }
        for(int i=0;i<b;i++){
            int g=sc.nextInt();
            m.append(g);
        }
      
        ll res=sum(h.hptr,m.hptr);
   
     
        res.display(res.hptr);
    }
    
}
***********************************************************************
You are given a string S, consist of both lowercase and uppercase alphabets.
Your task is to find out the length of the longest word W with the 
following properties:
	- The word should be the longest.
	- The word can be formed with letters of S, and you can shuffle the letters 
	as your need. You cannot use the letters more than their occurence count.
	- The word should be equal to the reverse of it.
	
NOTE: Alphabets are case sensitive
"Aa" is  not equal to "aA". The letters 'a' and 'A' are not same

Input Format:
-------------
A string S, consist of lower/uppercase letters

Output Format:
--------------
Print an integer, length of longest word W.


Sample Input-1:
---------------
abccccdd

Sample Output-1:
----------------
7

Explanation:
------------
One of the longest word can be formed is "ccdadcc", with length 7.


Sample Input-2:
---------------
AIbohPhObia

Sample Output-2:
----------------
5

Explanation:
------------
One of the longest word can be formed is "bhPhb", with length 5.



import java.util.*;
class re{
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        String v=sc.nextLine();
        HashMap<Character,Integer>p=new HashMap<>();
        for(int i=0;i<v.length();i++){
            p.put(v.charAt(i),p.getOrDefault(v.charAt(i),0)+1);
        }
        int res=0;
        int f=0;
        for(Character h:p.keySet()){
            if(p.get(h)%2==0){
                res=res+p.get(h);
            }
            else if(p.get(h)==1){
                f=1;
            }
            else if(p.get(h)%2!=0){
                int y=p.get(h)-(p.get(h)%2);
                if(p.get(h)%2==1){
                    f=1;
                }
                res=res+y;
            }
        }
        if(f==1){
            System.out.println(res+f);
        }
        else{
            System.out.println(res);
        }
    }
}
*****************************************************************************************************************
You are given a 32-bit signed integer N. Your task is to reverse 
the binary representation of N and print its decimal equivalent as integer. 

Input Format:
-------------
An integer, signed integer.

Output Format:
--------------
Print an integer output.


Sample Input-1:
---------------
1420227820

Sample Output-1:
----------------
925852970

Explanation:
------------
The given integer is 1420227820
binary representation is 01010100101001101111010011101100

Reverse binary representation is 00110111001011110110010100101010
so return 925852970.


Sample Input-2:
---------------
2132772745

Sample Output-2:
----------------
-1847461634

Explanation:
------------
The given integer is 2132772745
binary representation is 01111111000111111000011110001001, 

Reverse binary representation is 10010001111000011111100011111110
so return -1847461634.

import java.util.*;
import java.math.*;
class re{
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int f=sc.nextInt();
        StringBuilder v=new StringBuilder(Integer.toBinaryString(f));
    while(v.length()<32){
        v.insert(0,"0");
    }
        BigInteger t=new BigInteger(v.reverse().toString(),2);
        int g=t.intValue();
        System.out.println(g);
    }
}
***************************************************************
actorial of N means, Product first N natural numbers.
e.g., N= 1 * 2 * 3 * ... * N.

You are given an integer N,
Your task is to findout the number of 0's at the end of the factorial value of N.

for example : N =5 => Factorial of 5 is 120.
0' s at the end of 120 are 1.

Constraint : 1<= N <= 10000

Input Format:
-------------
An integer N

Output Format:
--------------
Print an integer, number of 0's at the end.


Sample Input-1:
---------------
5

Sample Output-1:
----------------
1

Explnation:
-----------
5! = 120, so the number of 0's at the end are 1. 


Sample Input-2:
---------------
4

Sample Output-2:
----------------
0

Explnation:
-----------
4! = 24, so the number of 0's at the end are 0. 














import java.util.*;
class re{
    
    public static int  tailingzero(int g){
      int m=g;
    int s=0;
    while(g/5>0){
        s=s+(g/5);
        g=g/5;
    }
      return s;
    }
    public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();
    
        System.out.println(tailingzero(a));
    }
}
*******************************